\documentclass{deliverablereport}

\deliverable{component-architecture}{multiplatform-buildbot}
\deliverydate{31/08/2018}
\duedate{31/08/2018 (M36)}
\author{Erik Bray, et. al.}

\usepackage{graphicx}
\usepackage{subcaption}

\begin{document}
\maketitle

\hypertarget{introduction}{%
\section{Introduction}\label{introduction}}

In this report we look at what some OpenDreamKit-affiliated projects have
achieved in the areas of continuous integration and multi-platform building and
testing.

Continuous integration (CI) in software development is a process whereby work
performed by one or more developers on a software project is regularly merged
together into a single, central software repository (referred to as the
'mainline'), and the software built and tested with success or failure of the
build reported quickly back to the developers of the project.  This helps to
ensure that individual developers' changes do not conflict with each other or
otherwise ``break the build'', and provides rapid feedback when breaking changes
are introduced into the mainline.  Both the process, and the associated tools
(e.g. automated continuous integration servers) are an essential part of the
day-to-day work of developers on those projects that use it.

Modern CI requires server infrastructure -- at the very least one machine which
is always running that both performs software builds and reports the results of
those builds back to developers so that are kept regularly up-to-date on the
``health'' of the build.  For some projects --  especially those that support
multiple software platforms -- continuous integration infrastructure can involve
a whole fleet of hardware systems, each of which perform builds and tests of
the software and report results back to a ``master server'' which collates them
into a single multi-platform build report for developers to examine.
Unsurprisingly, as the CI needs of a project grow, so to does the size of its
CI infrastructure, and the time, financial resources, and expertise required to
maintain it.

The \Sage project, being quite large both in terms of number of contributors
and in terms of overall code base (and by extension the length of time required
to build the software and run its test suite) has non-trivial CI needs, and to
address this it has, over time, amassed a small multi-platform fleet of build
machines as part of its ``buildbot'' infrastructure (based on the
Buildbot\footnote{\url{https://buildbot.net/}} CI software framework), as well
as expertise needed to maintain that infrastructure.  One of the original aims
of deliverable was to see if other projects under the OpenDreamKit umbrella
could benefit from using Sage's buildbots, and thus achieve better
multi-platform CI.  Additionally, we would look into widening the set of
platforms supported by Sage's buildbot infrastructure -- in particular adding
Windows builds to coincide with the Sage's newfound Windows support
\TODO{reference D3.7 here}.

In practice, the needs of the OpenDreamKit community as a whole with respect to
multi-platform CI, and in particular the need for a ``common infrastructure''
for CI, did align with our original expectations, for reasons that are
enumerated in the following section.  Nevertheless, significant achievements
were made by OpenDreamKit projects in the area of CI, and there are lessons
learned that we are communicating through this report in the hopes of future
cross-polination on the subject.  Our experiences have also taught us that
although there is not a one-size-fits-all solution to CI, there remains a clear
need in the community for easier access to multi-platform build and development
infrastructure, epecially for non-free operating systems such as Windows an Mac
OSX.

\hypertarget{changes-to-deliverable}{%
\section{Changes in scope of the deliverable}\label{changes-to-deliverable}}

In the last five years there has been a rise in free (especially for open
source) cloud-based continuous integration services that integrate closely with
source code hosting platforms like \GitHub and \GitLab.  This has precipitated
both an increase in use of CI as a best practice in the software community,
though conversely a decrease in the need for self-hosted and self-managed CI
infrastructure such as Sage's buildbots.

Although free-for-open-source cloud-based services were in use before the start
of OpenDreamKit\footnote{The popular Travis CI service saw rapid growth in
2012: \url{https://blog.travis-ci.com/2012-12-17-numbers/}}, there has been an
explosion in the number of services, including among others Travis CI,
CircleCI, AppVeyor, and now Microsoft has entered the field with its new
version of Visual Studio Team Services (VSTS).  For example, by their own
estimate\footnote{\url{https://blog.travis-ci.com/2016-07-28-what-we-learned-from-analyzing-2-million-travis-builds/}}in
2016 Travis CI was in use by nearly a third of active GitHub projects.  Without
the existence of these free services, most projects -- especially smaller
ones -- would not have the resources to maintain CI infrastructure even if they
wanted to.

Another advantage of services that integrate with \GitHub is that it enables a
particular type of continuous integration sometimes referred to as ``advisory
CI''.  This contrasts with traditional CI, wherein all developers on a project
are allowed to push changes to a central version control system, and the CI
system builds from that shared ``mainline''.  This means that a developer
pushes a change that breaks the code, while a correctly functioning CI system
should catch this bug fairly quickly, in the meantime the code is ``broken''
for all other developers on the project.

However, in distributed, open source projects like those hosted on \GitHub or
\GitLab, one does not want to give just anyone permission to push changes to
the mainline.  Instead, most developers submit {\em pull requests} -- a change
proposal that is not immediately merged into the mainline, but which a project
administrator with sufficiently high authority can pull changes from pull
requests into the mainline only after they have been reviewed and deemed
acceptable and sufficiently stable.  Advisory CI can help immensely in
determining when a proposed pull request is ``sufficiently stable''.  Under
this model the CI framework takes the latest version of the project's mainline,
applies the proposed changes on top of it (if possible -- if not the build is
rejected), and then attempts building the code and running its test suite with
just those changes applied.  If this works, then one can have reasonable
confidence (after a manual code review, and acceptance of the change on its
merits) that the change is safe to include in the mainline.  This is not a
silver bullet: it is possible that two mutually independent pull requests can
pass through the CI system on their own, but conflict with each other in a way
that is only apparent after they have been merged into the mainline.  In this
case one has the traditional CI problem of a ``broken build''.  But this
scenario is relatively uncommon, especially in well-structured projects.

Therefore, between the relative ease of setting up free continuous integration
systems for use on one's project, and the added convenience advisory CI that
integrates directly with the project's issue tracker, there is relatively
little demand for self-managed CI infrastructure such as that used for Sage.
However, there is still the question -- anticipated by the original proposal
for this deliverable -- of multi-platform continuous integration.  In fact,
this is also reasonably well-covered by free CI services.  While most services
provide building and testing of software on Linux distributions, some also have
fleets of different non-free OSes (e.g.~Travis CI supports builds on Mac OSX,
while AppVeyor is popular for its Windows support).  For projects wishing to
achieve some multi-platform support -- especially across those three major OSes
-- they can do so by configuring a combination of CI services for the project,
and many projects do just this.

In practice though, multi-platform CI has not has as much demand as we
anticipated.  Many mathematical software projects do not have a great deal
system-specific code, and are mostly numerical in nature (e.g.~C++ libraries
such as \Linbox and \Givaro), and have relatively little need for
multi-platform testing.  While platform-specific issues can still arise in such
software, it is not always typical enough to merit the extra overhead of
multi-platform testing.  When platform-specific issues do arise, it is more
common for them to occur when building the project, rather than at run time.
To this end, the \Sage project is already providing implicit cross-platform
build testing for many projects; see the next section for details.

\TODO{Say something here about conda-forge?}

\subsection{Sage remains a special case}
In Sage's case it is still useful, for now, to have the self-managed
infrastructure due to the unique nature of Sage and the fact that it includes
and entire software distribution.  Its builds can take a very long time and run
up against limits imposed by the free services, and it is also useful to test
Sage across a wide number of platforms due to the likelihood of
platform-specific build issues across its more than 150 dependencies.

It is also worth noting that being a software distribution comprising so many
components, Sage is providing implicit cross-platform build and runtime testing
OpenDreamKit-affiliated projects and dozens of other mathematical software
systems.  While Sage's test suite does not provide full test coverage for its
dependent packages, it does exercise most of them extensively.  In particular,
Sage tests all its dependencies at the system integration level (such as
interaction between multiple processes, and running multi-threaded
computations); these are the areas where the most platform-specific challenges
arise, as opposed to purely numerical and mathematical code.  In fact, the
process of porting Sage to Windows, and running Sage's tests on Windows
\TODO{Reference D3.7} has led to the discovery and fixing of these kinds of
system-level issues in software such as \GAP, ECL, and \PariGP among
others.\TODO{Add links to those issues?}

That said, there were also areas for improvement identified with Sage's
existing CI practices, especially with regard for its relatively unreliable
home-grown advisory CI system.  It was also realized that the now wide
availability of Docker as a tool for CI could be leveraged to both improve
Sage's CI practices, and make possibly make Sage development easier.  This
work is discussed further in the next section.


\TODO{Note issues with obtaining necessary hardware and software licenses for
CI/build on non-free platforms: Windows, and ESPECIALLY OSX?  Or save that
for later...?}


\hypertarget{project-reports}{%
\section{Continuous integration achievements of OpenDreamKit projects}\label{project-reports}}

\subsection{SageMath}

The SageMath project had traditionally employed two distinct CI systems, the
Buildbot and Sage's own development, the
patchbot\footnote{\url{https://github.com/sagemath/sage-patchbot}}.

\subsubsection{Buildbot and patchbot}
Sage's Buildbot runs as a non-advisory CI system on a wide variety of
platforms. It builds Sage and runs its test suite for every change that gets
accepted into the mainline of the Sage code. Its main purpose is not to be an
advisory tool for developers but to catch problems and incompatibilities of
Sage or its dependencies, in particular on more obscure platforms that
dependent projects do often not test for. Due to the vast range of platforms
covered, the Buildbot can not realistically be turned into an advisory CI
system as it is not conceivable to provision and administer the number of
machines that would be necessary to run Sage's test suite at every stage of a
test that gets proposed by a developer.

Therefore, the Sage community at some point developed its own patchbot system
which runs Sage's test suite at every stage of a proposed change. Anybody can
run a patchbot on their private computer, typically a Linux system. These
patchbots will then look for proposed changes to Sage, run Sage's test suite,
and report findings back to a central server. It is worth noting that the
patchbot system predates most of the currently popular CI systems.

The patchbot system comes with a number of issues: It is not nearly as polished
as the professional offerings which means that its workings can often be
confusing and that it also requires continuous maintenance and development from
the SageMath community and by those that run the patchbots on their private
machines. The fact that it is running on private machines means that due to
load, connectivity issues, and other temporary issues on these machines, the
patchbots are very frequently reporting false positives. This noise can be very
frustrating as it makes the patchbot system unreliable and in particular harder
to understand for new contributors. Finally, due to limitations of the patchbot
architecture, not all types of changes can be tested, in particular it can not
test changes that involve dependent software packages. This can be frustrating
as testing such changes is often the most time consuming task for developers
and it would be particularly nice to give such tasks away to a CI system.

\subsubsection{Modern CI with GitLab CI and CircleCI}
To fix these issues we were looking at best pratices that would give the
SageMath community fast, reproducible, reliable CI with minimal maintenance and
continuous development necessary to keep the CI working for everybody.  We
settled for GitLab CI, a modern open-source CI system, and CircleCI, a popular
closed-source system. Which one to use is up to each developer. For simplicity
we focus on GitLab CI here. GitLab CI typically uses Docker containers as its
backend (but it can also be based on many other technologies.) These containers
are essentially virtual machines that can be hosted in a central location but
also on private computers. Unlike in the patchbot systems, Docker containers
are standardized and isolated so that there is usually no issue of false
positives. % note that I do not distinguish between Docker containers and
% images; I think it's more confusing to the reader to make such a distinction.

GitLab CI now runs a "pipeline" for every change proposed by a developer.
\TODO{Insert \url{https://trac.sagemath.org/raw-attachment/ticket/24655/gitlab.png} here.}
This pipeline goes in stages. In the setup for SageMath, the first stage builds
several flavors of Docker container which contain a built version of Sage. The
second stage runs tests on these containers. Finally the Docker containers from
the first stage are made publicly available.

It should be noted that the first stage is where most complications for Sage
arise. Building Sage takes several hours on most machines, so a lot of effort
went into speeding this up in a sane and reproducible way to about 10 minutes.
Also, we try to make the resulting Docker containers as small as possible. This
speeds up the whole CI pipeline and also makes it easier for developers to
download these containers; in typical cases they only have to download a few MB
to get a hold of the Docker container.

\subsubsection{Use Cases of Docker Containers}
Having these Docker containers readily available as a by-product of our CI turned out to be very valuable.
\TODO{Maybe insert \url{https://trac.sagemath.org/raw-attachment/ticket/24655/dockerhub.png} here.}

It means that recent stable \& unstable versions of Sage are automatically made
available for anybody to work with, without the need of having to understand
how to build Sage on their machine.

Sage developers can use these to reproduce and understand issues
reported by the CI system. Simply by downloading the container and running the
Sage contained in that container.

Projects that depend on Sage can use these Docker containers for their own CI
needs and run their tests based on these containers. Without such Docker
containers, most such projects would refrain from using CI as setting up Sage
in a CI system appeared to be too complicated.

Sage (and projects depending on Sage) can link to these containers through
mybinder.org \TODO{link to something, maybe screenshot something?} to make
different versions of their systems available through public web interfaces.
This means that anybody can easily experiment with the latest unreleased
features in a web browser without having to go through any local installation.

\subsection{GAP}

% Via Alex [can he write a couple paragraphs about this?]:
% I will be ready to add a section with the overview of the current state of
% continuous integration in GAP. In addition to the private Jenkins CI instance
% that we use for wrapping and testing release candidates, checking for GAP
% package updates and testing new versions of GAP packages, we now use Travis
% CI to run a number of tests for the main GAP repositories at
% https://travis-ci.org/gap-system/. These include not only CI test for the
% main GAP development repository, but also package integration tests that use
% a set of Docker containers build in various settings
% (https://hub.docker.com/r/gapsystem/). We have a standard CI setup for GAP
% packages, which package authors may adopt and customise. GAP packages using
% Travis CI in the gap-packages VO can be seen at
% https://travis-ci.org/gap-packages/ (some more at
% https://gap-packages.github.io/). Also, GAP and packages use CodeCov to
% measure code coverage: see https://codecov.io/gh/gap-system/gap for GAP and
% https://codecov.io/gh/gap-packages/ for GAP packages.
% 
% @embray
% > Much of the context to this deliverable is about multi-platform testing and
% support. What aspect of our work addresses this? The Travis-CI builds for GAP
% appear to be entirely, or at least almost entirely for Linux (@alex-konovalov
% can clarify). I don't see any OSX builds, and Travis does not support
% Windows.
% Good point about Windows - forgot to mention that we also use AppVeyor:
% https://ci.appveyor.com/project/gap-system/gap

% About Linux vs macOS: package integration tests (all but one badges at
% https://github.com/gap-system/gap-distribution) use Docker container, hence
% use Linux. The core system tests used both Linux and macOS builds in the
% past, but then were disabled because of performance problems:

% https://github.com/gap-system/gap/blob/c8104cd056833f60c9f40efcb81b37b9cec76198/.travis.yml#L66

% We have all three systems - Linux, Windows and macOS - available as Jenkins
% nodes in St Andrews, so we find this to be satisfactory for the moment.


\subsection{Singular}


% Maybe ??

\subsection{PARI}

% Maybe ??

\subsection{Cysignals}

The Cysignals
project\footnote{\url{https://cysignals.readthedocs.io/en/latest/}} has been
using Travis CI\footnote{\url{https://travis-ci.org/sagemath/cysignals}} for
continuous integration on Linux practically since its inception (see \TODO{link
to D4.1 which contains first mention of cysignals}).  In Spring of 2018 we made
initial progress towards adding native Windows support to
Cysignals\footnote{\url{https://github.com/sagemath/cysignals/pull/76}} as well
as continuous integration for both native Windows and Cysignals on Cygwin using
AppVeyor\footnote{\url{https://github.com/sagemath/cysignals/pull/95}}, the
initial results of which have been promising.  The process of adding Cygwin
testing on AppVeyor even exposed new Cygwin-specific bugs with Cysignals that
had not been previously caught.

However, multi-platform testing still remains an interesting problem for
Cysignals in particular.  The low-level details of Cysignals are such that its
functionality can depend heavily on the underlying operating system kernel
(even different versions of the Linux kernel).  As such, one would like to be
able to test against different kernels.  Because most CI services -- including
Travis CI -- are using container-based technology, this means that even testing
different OS platforms via containers is not entirely helpful, because all
containers running on the system host system are using the same underlying
kernel.

Thus, an area for future work might be to try using GitLab's CI framework and
providing our own build runner machines (possibly even reusing the existing one
from Sage's buildbot fleet) to test Cysignals against more OS platforms with a
wider range of OS kernels than we might test otherwise.

\hypertarget{best-practices}{%
\section{Lessons learned and best practices}\label{best-practices}}
\end{document}

\TODO{This section might summarize some key bullet-points from the previous sections.}

\TODO{We might want an additional section to discuss future work.  In
particular, Nicolas and I discussed the possibility of getting in touch with
EGI and seeing if we might be able to use EGI-provided resources for a
multi-platform cloud environment specifically for use by open source
mathematics projects.  In particular we would want this to be provided in such
a way that it isn't restricted to projects that are strictly European by nature
(or maybe at the most have some European grant or contributors associated with
it).}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
