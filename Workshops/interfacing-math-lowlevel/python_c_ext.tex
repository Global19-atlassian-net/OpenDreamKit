\subsubsection{DragonFFI}

Foreign Function Interface to transparently call C functions from Python

DragonFFI is a Python library that lets a Python program analyze on the fly the C-header file, or shared library with debugging information,
and then transparently call the C functions of that library:

\begin{lstlisting}
    import pydffi
    F = pydffi.FFI()
    CU = F.cdef("include <stdlib.h>")
    print(float(CU.funcs.atof("4.5")))
\end{lstlisting}

One can also compile additional code:

\begin{lstlisting}
    CU = F.compile("__attribute__((ms_abi)) int foo(int a, int b) { return a*b; }")
    int(CU.funcs.foo(4,-7))

     Not in stable version
    CU=F.from_dwarf("/path/to/libarchive/build_clang_full_relwithdeb/./libarchive/libarchive.so")
    a = funcs.archive_read_new()
    ...
\end{lstlisting}

Implementation:

Goal: Avoid C ABI chaos.

Clang AST is too high-level (includes irrelevant info like source code locations, no information about type sizes, struct padding, etc...), LLVM IR is too low-level (i.e.: structure coersing, can make structures "disappear) 
dragonffi uses LLVM-IR + DWARF debug info to generate wrappers automatically from a header file, or even from
a shared library (not yet windows), generated by clang or gcc.

Dependencies:
    * python pip package (wheel): everything statically compiled
    * compilation by hand: Clang/LLVM 5.0 (see https://github.com/aguinet/dragonffi/llvm5-compilation )

\subsubsection{libffi}

reference impl of various C ABIs) -> cffi (higher-level Python interface based on pycparser)

Problem: libffi is hard to work on (hand-written ASM), cffi is limited.


\subsubsection{cppyy}

generates Python bindings for C++
supports many language features including templates, inheritance, exceptions

requires compiling the sources with clang to do introspection on the binary

% PyROOT (built on cppyy)
%
% ROOT
%
%(Enrico Guiraud, PhD in the ROOT team)
%
%ROOT is a large C++ HEP data IO and analysis framework (2.5 M lines). It's mission is to get physicists quickly from
%collision to publication.
%
%HEP will soon suffer from an explosion of data processing & storage requirements, question is, how do we handle that?
%
%ROOT tries to build a convenient high-level interface which helps physicists easily write performant code.
%
%Introducing a data frame like abstraction in C++ (MapReduce-ish interface that compiles down to efficient parallel machine code).
%
%Filters, and other operations typically take a lambda function as arguments.
%Practice says this is a bit heavy handed for a typical physicists; for convenience
%one can instead pass an expression represented as a string. It will be Just in Time translated to lambda function then JIT compiled
%to native code using cling.
%
%One goal of the DataFrame-ish interface is to silently eliminate duplicate computation/IO ("looping 5 times over 5GB of data if that's the most convenient way to produce a plot")
%
%Interoperates with multiple data sources (not just ROOT, also CSV and others...)
%
% PyROOT = ROOT + cppyy
%
%The bindings are generated using cppyy.
%The later uses introspection on C++ code and generate Python wrappers for all ROOT types and methods.
%The wrappers can be generated at compile time (45 minutes for all of root). But it can also be done
%at runtime, e.g. when you want to dynamically add C++ code. cppyy support templates, ...
%Templates are handled through a proxy function that instantiates the vector on the fly
%
%Requirements:
%- Running cppyy requires cling (and thus clang, llvm). But once the wrappers have been generated,
%  clang is no more a compile-time dependency. They could be used with another C++ compiler.
%- CPython?
%
%Open problem: turn python code passed from the Python interpreter into native code that can be executed in the native world (as a native callback)
%
% SWAN
%
%A CERN hosted web service giving access to all ROOT Software and CERN data, with Jupyter notebooks,
%C++ and Python kernels, ...

 Integration Solutions: Other CAS <-> C/C++

 CyPari: Pari <-> C

Strategy: The code of Pari comes endowed with a description of each function:

TODO: insert example here

From this code, cypari autogenerates the following Cython binding which is then compiled to C:

TODO: insert example here

TODO: blurb about types: Pari has a dozen types of objects; conversions between Pari types and Sage types is written by hand.

 libsemigroups: GAP <-> C

libsemigroups is a C++11 library for computational semigroups. It was written with three goals in mind: accelerate core code from GAP's semigroup package (low level language, parallelism, ...), include a modernized existing C library Semigroupe (parallelism, design issues), and make the result available to a larger community (GAP, )
Distribution: conda and github but no wheel (supposedly not well suited)
    
 GAP bindings

TODO: summary, pros, cons

Original version: handwritten
    
Conversion overhead but still faster than original computation (unlike numpy approach)

Second attempt: mimic pybind11 using compile time introspection (presumably available in both clang and g++).

 Python bindings

Handwritten using Cython; totally incomplete and painful to maintain

Potential plan for writing a C API, because many languages (clojure, ...) can directly call C code 

 Difficulties
- "old" compilers don't quite support C++ 11 (old but still current in conda, GAP tests, and other systems, at that point)
- code duplication
- *not* tested on windows; would presumably work on cygwin and windows subsystem but not natively (relies on automake/autoconf)

 Julia <-> C

Sebastian and Thomas)

Features:
- Implemented as a GAP package JuliaInterface
- works on top of vanilla GAP and Julia (some improvements will be submitted upstream GAP for tighter integration)
- conversions between GAP and Julia objects
- Manipulate Julia objects from GAP via handles
- Manipulate GAP objects from Julia via handles
- Run arbitrary Julia functions from GAP by name
- Evaluate arbitrary Julia commands as strings
- Application: load Julia code that calls back to GAP; this can lead to 20x speed improvements,
  presumably due to compilation + use of native Julia data structures (lists, ...) that are faster
  than GAP's.

Implementation:
- GAP and Julia cohabit in the same memory space, and interact through their C-API.
- Currently each system uses its own garbage collector, with GAP keeping a list
  of Julia objects; this leads to loops, and therefore memory leaks.
- The next step is to add a compilation option to GAP to make it optionally use
  Julia's garbage collector instead of it's own. Same for HPC-GAP?
- Same strategy as cypari, ...: stay lazy and convert objects only if really needed

Demo of calling functionalities of Nemo, Arb, ...

Difficulties:
- Cost of conversions; for example for big integers: the representation in gap isn't the same as in Julia => costly translation (sometimes carried through strings!), question is when to do it?
- Julia currently recompiles all loaded code (e.g. the interface to Singular) on the fly. This is slow and a big
  burden in practice. The Julia folks are working on caching.

- Would it make sense to 
- How comes that Singular is so slow to start (compared to launching a plain Singular):
- Semantic handles: thinking about it; not clear best way to proceed

 PolyMake (Perl) <-> C++

PolyMake is a combination of C++ code (for hard core calculation) and Perl code
(for high level mathematical features, with a rule-based mechanism).
It also includes many external C or C++ libraries.
C++ and the Perl interpreter share the same memory space. In general it's mostly Perl
calling C++ (with features like automatic instantiation of templates). But its also possible
to call PolyMake from C++ (including all the rule-based Perl mechanism).

Mechanism to generate the Perl bindings to the C++ code? Kinda similar pybind11
And a declaration mechanism similar to Cython pxd's

The rule-based mechanism is essentially a method selection mechanism,
filling a similar purpose to GAP's method selection mechanism (or Sage's categories).
It has different features though; possibly more powerful.
filling a similar purpose to GAP's method selection mechanism (or Sage's categories).
It has different features though; possibly more powerful.


Various other presentations from the workshop

 SageMath

 Overview

- A general purpose Python based software for mathematics
- Tens of libraries interfaced

For most libraries, users don't actually see the underlying software; they use SageMath objects, and it just turns out that some of them use internally data structures or functions from the library.

Exceptions: for Pari / GAP the interface gives full access to all the commands of the library.

 Strategies

For most C/C++ libraries, SageMath uses Cython to write bindings.

Drawbacks:

This typically requires lots of boilerplate. Typically writing a Cython header file which is duplicating the library header file (or whatever subset is used). TODO: include here the example from Jeroen's talk. Also, for C++ libraries, something to be done for each method / ...

 xtensor: The Lazy Tensor Algebra Expression System

Many scientific languages wrapping same core data structures (nd-array + data frames
(e.g. Python with numpy\&pandas, Julia with..., R with ...).

Goal: decouple the data storage from the computations, so that data could be in memory, on disk, in the cloud...

xtensor provides a lazy container with a semantic similar to Numpy arrays. However operations
are not evaluated immediately. Instead they return lazy expressions that are
only computed upon value access or assigning to a container (expression template inside)

xtensor can wrap numpy arrays, Julia arrays, R arrays ...

Bindings:
    - BLAS bindings for BLAS operations on xtensor expressions
   - fftw
   
Question: how does it relate to Apache Arrow

Upcoming: xframe: the analogue of xtensor for dataframes instead of arrays

xtensor cookie cutter to gather best practices in bundling native libraries and deploying them for julia / R / python when based on xtensor

 Data analysis for High Energy Physics

Issues different from the typical HPC; the data is typically highly nested, and can't be flatten

 Not new: splitting complex arrays into columns (Apache Arrow)

Sort of proxy: code holds empty arrays then fetches the columns JIT

 New technique: Object Array mapping

Goal: translate user-written traditional object-oriented code into HPC-like array operations at runtime

Type checking through numba type extension system
Extends Numba to generate the appropriate pointer arithmetics to reach the correct data when a specific type  is used. Numba provides an extension mechanism to control the emitted LLVM bytecode for custom types.

 xeus-cling

xeus: framework for building Jupyter kernels
cling: C++ interpreter

A cool demo of interactive C++, with widgets, images, sound, interactive map drawing:
https://beta.mybinder.org/v2/gh/QuantStack/xeus-cling/0.4.2?filepath=notebooks/xcpp.ipynb

provide the conversion wrapper for pybind11 for their various data types

