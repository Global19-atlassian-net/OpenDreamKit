\documentclass{deliverablereport}

\deliverable{dksbases}{persistent-memoization}
\deliverydate{XX/YY/201Z}
\duedate{28/02/2019 (M42)}
\author{Michael Torpey}

\usepackage{multicol}
\usepackage{multirow}

\newcommand{\pypersist}{\texttt{pypersist}}

\begin{document}
\maketitle
% This will be the abstract, fetched from the github description
\githubissuedescription

% write the report here

\section{Introduction}
\label{sec:intro}

% What is memoisation?
\textbf{Persistent memoisation} refers to the computational practice of storing
program results whenever they are computed, and then looking up and retrieving
them later, instead of re-running programs that are guaranteed to return the
same answer.  This approach allows users to avoid unnecessary computation, and
makes it possible to create an archive of results that can be used for other
purposes later.

% Why is it good for maths?
This approach may be useful in a wide range of fields, but it is particularly
relevant to mathematics because of the type of problems mathematicians wish to
solve.  Mathematics is a rare example of a field with algorithms that require a
lot of processing, but have a small input and small output.

Many algorithms in the real world have a large input and a small output -- for
example, the problem of determining which streamed TV show to recommend to a
viewer takes as its input a huge amount of data about past choices consumers
have made, and returns a single title as its output.  The output of this
function can be stored easily, but so much time would be spent processing the
large input, and the same input would be repeated so infrequently, that this
type of memoisation would have little advantage.

Conversely, many algorithms have a small input and a large output -- for
example, rendering a plain text file on a screen takes a small amount of data as
an input, but creates an image which is likely to be large if stored.  In this
case, the input can be dealt with quickly, but memoising the output using a disk
is likely to be slower than recomputing it from scratch each time.

In mathematics, however, we frequently encounter computational problems with
both small input and small output.  For instance, we may wish to know whether a
given permutation group $G$ is simple; the input may be two or three generators
for $G$, which between them use only a few bytes on a computer, and the output
is a single boolean.  But despite the small sizes of these data sets, the
algorithm may take a long time to complete, and may use a large amount of memory
while in progress.  Thus, memoising results of this type will use very little
disk space, require very little processing, and may avoid a huge amount of work
when recalling previously computed results.

Furthermore, there is no reason that a memoisation cache should be limited to a
single user.  A memoisation framework could save results to a shared directory
for immediate use by other researchers connected by a network, or could even
use an online database for the cache, so long as sufficient precautions were
taken to avoid reading and writing clashes.

Besides the obvious advantages of recalling cached results instead of repeating
work, a memoisation framework that allows a human-readable cache could be used
by researchers to create a reproducible record of computed results that can be
included in papers, or shared with collaborators that have no knowledge of the
memoisation system.

The aim of ODK Task 6.9 is to establish a persistent memoisation framework to
cache results in Python and GAP across sessions, in a way that is easy to deploy
and configure, and allows for results to be shared reliably between different
researchers.  Deliverable 6.9 requires a ``shared persistent memoisation library
for Python/Sage'', which is fulfilled by \pypersist{}, a new Python library
written by the current author.  The corresponding software for GAP is in
progress, in the form of GAP's \texttt{Memoisation} package, which aims to have
the same features as \pypersist{}, and to be as compatible as possible with it.

In this report, we will present a review of some existing tools for memoisation
(Section \ref{sec:existing}), describe the new Python library \pypersist{}
(Section \ref{sec:pypersist}), and give an overview of the future direction of
this project (Section \ref{sec:future}).

\section{Existing tools}
\label{sec:existing}

In this section we will consider some tools that already exist for memoisation,
with a focus on Python and Sage tools.  Some of the tools we discuss are only
intended for a subset of the complete memoisation process, while others are more
full-featured but lack some important desirable features.  A comparison of these
tools is shown in Table \ref{tab:comparison-of-tools}.

\begin{table}[h]
  \renewcommand{\arraystretch}{1.2}
  \begin{tabular}{|l|c|c|c|c|c|c|c|c|c|c|}\cline{2-11}
    \multicolumn{1}{c|}{ }
    & \rotatebox{270}{Updated in last year~~}
    & \rotatebox{270}{Python versions}
    & \rotatebox{270}{Function decorator}
    & \rotatebox{270}{In-session caching}
    & \rotatebox{270}{Disk caching}
    & \rotatebox{270}{Database caching}
    & \rotatebox{270}{Custom keys}
    & \rotatebox{270}{Custom pickling}
    & \rotatebox{270}{Metadata}  % TODO in pypersist
    & \rotatebox{270}{Sage support}  % TODO in pypersist
    \\ \hline
    GAP operation/attribute & \checkmark & --- &  & \checkmark &  &  &  &  &  & \\ \hline
    Sage \texttt{func\_persist} & \checkmark & Sage & \checkmark & \checkmark & \checkmark &  &  &  &  & \checkmark \\ \hline
    Sage \texttt{cached\_function} & \checkmark & Sage & \checkmark & \checkmark & \checkmark &  & \checkmark &  &  & \checkmark \\ \hline
    Sage \texttt{cached\_method} & \checkmark & Sage & \checkmark & \checkmark & \checkmark &  & \checkmark &  &  & \checkmark \\ \hline
    \texttt{persist} &  & $2/3$ &  & \checkmark & \checkmark &  &  &  &  & \\ \hline
    \texttt{PyMemoize} & \checkmark & $2/3$ & \checkmark & \checkmark & \checkmark &  &  &  &  & \\ \hline
    \texttt{redis-simple-cache} &  & $2/3$ & \checkmark & \checkmark & \checkmark & \checkmark &  &  &  & \\ \hline
    \texttt{dogpile.cache} & \checkmark & $2/3$ & \checkmark & \checkmark & \checkmark & \checkmark & \checkmark &  &  & \\ \hline
    \texttt{pypersist} & \checkmark & $2/3$ & \checkmark & \checkmark & \checkmark & \checkmark & \checkmark & \checkmark & \checkmark & \checkmark \\
    \hline
  \end{tabular}
  \vspace{7pt}
  \caption{Comparison of memoisation tools}
  \label{tab:comparison-of-tools}
\end{table}

First, we should consider the existing persistence tools built into GAP and
Sage.  GAP functions can be installed as methods for an object's
\emph{operations} and \emph{attributes}, and if they are, their results are
stored for the duration of the current GAP session.  However, these results are
never saved to disk unless the session itself is stored, and the option is only
available for methods of an object.

There exists in Sage a simple function decorator, \texttt{func\_persist}, which
can be applied to a function to save its output to disk.  This is a working
memoisation tool, and even this functionality has great practical use, but the
tool has very little configurability: the only option that can be given is to
specify the directory in which results are stored.  Sage also contains two more
configurable tools for memoising functions and methods, respectively named
\texttt{cached\_function} and \texttt{cached\_method}.  These allow a function
or method to be memoised with a custom key-generating function, meaning that
arguments can be pre-processed in an intelligent way, perhaps to sort arguments,
or discard arguments that do not affect the return value of a function.

These three decorators are useful, but limited.  Not only do they lack certain
options such as database caching and custom output pickling, but they rely on
other parts of the Sage system, and therefore cannot be used more broadly in
generic Python programs.  Python memoisation tools exist outside Sage that can
in principle be applied to Sage.

Many memoisation tools are available on PyPI, each with a slightly different
philosophy and set of features.  Table \ref{tab:comparison-of-tools} summarises
four examples of these, indicating each one's features and status:
\texttt{persist} and \texttt{redis-simple-cache} have not been updated in
several years, while \texttt{PyMemoize} lacks even the custom key function
provided by the Sage tools.

Perhaps the most promising of the existing tools is \texttt{dogpile.cache}, an
API for caching function outputs to a variety of backends; this is a
well-established, full-featured system, but it lacks certain features such as
custom result pickling -- particularly useful to mathematicians who may want to
store output using OpenMath, or in some human-readable form for sharing.

There would be an argument for modifying and improving \texttt{dogpile.cache} to
add these features, rather than creating a new tool.  However, given the wide
scope of the \texttt{dogpile} project, which is largely focused on thread
management, it was decided to proceed with a new tool that could be adapted more
easily to suit the specific requirements of the project, such as bespoke support
for Sage-specific objects, and compatibility with the GAP memoisation package
which would be developed in parallel.

To fulfill these requirements, the \pypersist{} package was created.  It runs in
Python version 2 and 3, and it contains all the features mentioned in Table
\ref{tab:comparison-of-tools}.  More information about \pypersist{} is given in
Section \ref{sec:pypersist}.

\section{pypersist}
\label{sec:pypersist}

% all its features
% documentation
% pypi distribution
% python 2 and 3
% good practice checklist:

\paragraph{Software engineering}
Use of
\begin{table}[h]
  \renewcommand{\arraystretch}{1.2}
  \begin{tabular}{|p{5.1cm}|c|p{9.5cm}|}\hline
    Version control & \checkmark & Git \\ \hline
    Tests & \checkmark & \multirow{2}{*}{\emph{pytest} suite with 98\% code coverage} \\ \cline{1-2}
    Automated tests & \checkmark & \\ \hline
    Continuous integration & \checkmark & Travis runs test suite for every commit \\ \hline
    Automatic building of releases & \checkmark & PyPI release script \\ \hline
  \end{tabular}
  \vspace{0pt}
  \caption{Software engineering checklist for \pypersist{}}
  \label{tab:pypersist-se-check}
\end{table}

\paragraph{Dissemination}
\begin{table}[h]
  \renewcommand{\arraystretch}{1.2}
  \begin{tabular}{|p{5.1cm}|c|p{9.5cm}|}\hline
    Host code publicly & \checkmark & \url{https://github.com/mtorpey/pypersist} \\ \hline
    Reference Manual (APIs) & \checkmark & \url{https://pypersist.readthedocs.io} \\ \hline
    Tutorial (for beginning users) & \checkmark & \multirow{3}{9.5cm}{Examples section in readme, and Binder demo with extensive annotations: \texttt{binder/demo.ipynb} \\ (linked from readme and manual)} \\ \cline{1-2}
    Examples & \checkmark & \\ \cline{1-2}
    Live interactive online demos & \checkmark & \\ \hline
    Support mechanisms & \checkmark & Github issues \\ \hline
    How to cite the output? &  & TODO \\ \hline
    Installation mechanism & \checkmark & Installation via \emph{pip}, explained in readme and manual \\ \hline
    High level description accessible to non-experts & \checkmark & In readme, manual and Binder \\ \hline
    URLs/Blog/etc to and from OpenDreamKit project & \checkmark & Links to OpenDreamKit in readme, in manual, and on PyPI distribution page \\ \hline
    Grant acknowledgements & & TODO \\ \hline
    Open Source license & & TODO \\ \hline
    Workshop & \checkmark & \multirow{2}{9.6cm}{Demo and discussion at \emph{Free Computational Mathematics} conference, CIRM, Luminy, France, Feb 2019} \\ \cline{1-2}
    Engaging users & \checkmark & \\ \hline
  \end{tabular}
  \vspace{0pt}
  \caption{Dissemination checklist for \pypersist{}}
  \label{tab:pypersist-diss-check}
\end{table}

\paragraph{Pathways to impact}
\begin{itemize}
\item[{$\square$}] Does the software address the needs of the users?
\item[{$\square$}] Workshops to gather feedback
\end{itemize}

% things not fulfilled from checklist
% deviations from original specification: why we don't use other technologies

\section{Future direction}
\label{sec:future}

% future features in pypersist
% integrate into Sage, replacing other things?
% GAP version that works with it.  Mention current prototype.

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:

