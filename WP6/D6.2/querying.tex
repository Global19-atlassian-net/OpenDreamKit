In the case of some underlying database
this corresponds perfectly to the CRUD -- Create, Read, Update, Delete -- operations.
We can
just translate the operations and have the database take care of the implementation details. We
have already had a few more thoughts on how to enable efficient querying of theories -- we will
get to this later in Section~\ref{sec:querying}.

So far we have only concerned ourselves with accessing DK theories one declaration at a
time. This shows that DK theories are indeed useful, however in general one wants to be
able to access multiple declarations at once. Even though it is not the focus of this
report, we have had some thoughts about this.

Querying is the act of finding all declarations subject to some arbitary
criterion. Practically relevant queries can range from very simple queries -- such as find
all OEIS sequences containing a certain number -- to computationally intensive tasks, such
as find all elliptic curves with a conductor divisible by five\footnote{This particular
  example was given to us by John Cremona when asked for queries that the current
  architecture can not solve. }.

There gives a wide range of interesting questions that one might want to implement a query
engine for. Since most of the declarations that one wants to query over a big, one does
not want to evaluate each query by iterating over the entire set -- this is far to
slow. Thus a naive approach consists of iterating over all declarations beforehand,
finding all occuring values, and storing all of these inside a hash table. Such as index
can easily answer the first question from above. On top of this someone might want to find
sequences starting with a given integer. In this case we should either build a second
index that only contains starting numbers, or expand the first index in a smart
fashion. Another interesting query can be to find OEIS sequences containing arbitary
subsequences -- in which case the index no needs to contain any possible
subsequence. Eventually the index will explode -- the last addition would already scale
exponentially.

To be able to answer the second question above, one might want to take all occuring values
(in this case integers) and factorise them. Again we can store this in some form of
index. This can also be extended to polynomials -- which would allow users to search
polynomials based on their roots. Also in this situation it is very easy to underestimate
the complexity of the index.

It comes down to finding a good balance between interesting and useful queries and size
and scalability of the index. This in and of itself is a non-trvivial research task. In
the scope of K-theories we have solved parts of this question already. For example we have
built a general purpose query language for \MMT. We have also built MathWebSearch that
allows users to search for certain mathematical expressions within document corpera. We
will not discuss this here -- interested readers should take a look at \cite{Rabe:qlfml12}
and \cite{ODK-D6.1} for details.

In the future of the OpenDreamKit project we want to investigate this question for
DK-theories further. We want to take a deeper look at useful query languages. This could
consist of extending codecs from a value-translating mechanism to a query-translating
mechanism. That is we take a query from inside \MMT and then compile this into a database
query -- which can then be evaluated efficiently. It could also take another direction
entirely.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "report"
%%% End:
