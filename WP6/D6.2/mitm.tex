When integrating multiple systems we are mostly talking about using concrete algorithms
(implemented by these systems) to solve specific computational problems (the knowledge
about the problem). To integrate multiple systems with this knowledge we want to enable
users to write down a problem in one system and then solve it in another system. We want
to be independent of the implementation of the knowledge -- independent of the systems.

For this we make use of an approach we call ``Math-In-The-Middle'' paradigm
(see~\cite{DehKohKon:iop16} for details). Here the underlying mathematical knowledge, the
``real math'', is used as a reference ontology for system (in the ``middle'') -- hence the
name. Each system needs access to this knowledge. As each of them come with their own
particularities, they will need some interface to it.

We want to make use of the modular approach to mathematics provided by theory graphs, and
in particular \MMT as an implementation thereof, to first of all allow us translate
mathematical expressions between systems. We define a ``Math In The Middle'' theory as
well as interface theories for each system. With the help of \MMT and bi-views\footnote{A
  bi-view is a bidirectional view between two theories. } between the interface theories and
the central theory, we can translate objects from one system to the other.

\begin{figure}[ht]\centering
  \def\myxscale{3}\def\myyscale{1.2}
  \input{../CICM2016/tikz/kf-paradigm}
  \caption{The MitM paradigm in detail. PyF, C${}^{++}$F and CompF are (basic)
    foundational theories for \python, C${}^{++}$ and a generic computational model. SEC,
    LEC and GEC are theories for \SageMath, \LMFDB and \GAP elliptic curves.}\label{fig:mitm}
\end{figure}

A sketch of the theory graph based on the example of elliptic curves can be found in
Figure~\ref{sec:mitm}. We will not go into details here but show how this architecture
integrates the \emph{Software} and \emph{Knowledge Aspects}. Clearly, the (hand-curated)
MitM ontology -- the purple cloud in the middle -- is a specification of the underlying
mathematical knowledge as an OMDoc/MMT theory graph, while the system interface theories
-- the blue clouds around it -- formally specify the names and types (i.e. the argument
patterns) and intended behaviour of the interface functions of the systems (often
semi-formally to make the MitM approach scalable). The OMDoc/MMT views -- the wavy arrows
between the theories -- are interpretation morphisms; in this particular case where they
connect the mathematical specification to the system theories, they express the
``implementation relation''. Thus the OMDoc/MMT framework already allows to integrate the
knowledge and software aspects for system interoperability.

The restriction to formalizing the signature (i.e. names and types of the interface
functions) of the systems is sufficient to ensure system interoperability; integrating the
implementations -- e.g. C\textsuperscript{++} or Python code -- into the theories would
be overkill here, since the code can only be executed by the respective systems --
i.e. \GAP or \SageMath. Therefore we will base our foundation on OMDoc/MMT theory graphs
directly rather than on an extension of OMDoc/MMT with ``biform
theories''~\cite{KohManRab:aumftg13,Farmer:btc07} as envisioned in the proposal. Biform
theories would enable (partial) verification of mathematical software systems, but this is
not on the critical path towards a mathematical VRE. The MitM paradigm constitutes a
lightweight alternative; identifying and refining it has been one of the major
achievements of the first year in \WPref{dksbases}.
