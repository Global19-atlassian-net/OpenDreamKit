Based on a survey of the OpenDreamKit systems, we have identified the following types for the MitM Foundation (see Section \ref{sec:foundation}); see Appendix~\ref{app:expr} for an exemplary list of mathematical objects that can be represented as a members of these types.

\subsection{Base Types}
\begin{compactitem}
 \item number types (all unbounded in size):
  \begin{compactitem}
   \item natural numbers: $N$ (including $0$), $Pos$ (positive, excluding $0$), $Prime$ (prime numbers, not excluding $0$ and $1$)
   \item integer numbers: $Z$
   \item integer numbers modulo $m$: $Z(m)$ (for $m\in Pos$)
   \item rational numbers: $Q$
   \item real numbers: $R$ \ednote{FR: it's unclear which irrational numbers we need to support and how to represent them}
   \item complex numbers: $C$
   \item $p$-adic numbers: $Qp(p)$ (for prime $p$)
  \end{compactitem}
 \item strings: $String$
 \item booleans: $Boolean$
 \end{compactitem}

 \subsection{Complex Types}
 \begin{itemize}
\item Function types
 \begin{itemize}
 \item the type $T_1\to T_2$ of total functions from $T_1$ to $T_2$,
 \item shallow polymorphic types $\{a_1,\ldots,a_n\}T(a_1,\ldots,a_n)$ for a type $T$ with $n$ free type variables, with the restriction that polymorphic types may not occur as subexpressions of any of the other type constructors,
 \end{itemize}
\item Aggregating type constructors for types $T_1,\ldots,T_n$
\begin{compactitem}
 \item product types: $T_1*\cdots * T_n$
 \item record types: $\record{a_1: T_1, \ldots, a_n:T_n}$ for identifiers $a_i$
 \item disjoint union types: $T_1+\ldots + T_n$ \ednote{FR: not sure if we need these as they rarely come up yet as they are dual to product types}
 \item labeled disjoint union types: $\union{a_1:T_1,\ldots,a_n: T_n}$ for identifiers $a_i$ \ednote{FR: not sure if we need these as they rarely come up yet; they are dual to record types}
\end{compactitem}
In record and labeled disjoint union types, the order of fields is not relevant.
\item Collecting type constructors for any type $T$
\begin{compactitem}
 \item option types (list of length up to $1$): $Opt(T)$
 \item vectors (fixed-length lists): $Vec(T,n)$ for $n\in N$
 \item lists (arbitrary finite length): $List(T)$
 \item sets (finite subsets): $FiniteSet(T)$
 \item multisets (finite multiset subsets): $FiniteMultiset(T)$
 \item finite hybrid sets: $FiniteHybridset(T)$ are like multisets but also allow negative
   multiplicities.
 \item matrices: $Mat(T,m,n)$ for $m,n\in N$
\end{compactitem}
\item Erasure of dependent parameters: for a type constructor $T(k)$ (not necessarily unary) that takes a parameter $k$ of number type, we write $T(\_)$ for the type obtained by taking the unions over all possible parameters. In particular, we have
\begin{compactitem}
 \item $Mat(T,m,\_)$, $Mat(T,\_,n)$ and $Mat(T,\_,\_)$ for matrices with arbitrary dimensions
 \item $List(T)=Vec(T,\_)$
 \end{compactitem}
\end{itemize}

\subsection{Types for Mathematical Structures and their Models}

\begin{compactitem}
 \item finite maps (partial functions with finite support): $FiniteMap(T_1,T_2)$ for types $T_i$
 \item polynomials: $Polynomial(r,[x_1,\ldots x_n])$ for ring $r\in Ring$ and identifiers $x_i$
 \item rings: $Ring$ (multiplication is a commutative monoid)
 \item fields: $Field$
 \item elements of structures: every structure $S$ (e.g., $S\in Ring$ or $S\in Field$) is a type itself; the elements of $S$ are represented as elements of the underlying type of $S$, which must be defined separately for every structure $S$.
\end{compactitem}
More generally than fixing $Ring$ and $Field$, we actually allow $Mod(T)$ for any theory $T$.
But the types listed above are sufficient for our purposes here.

\subsection{Subtyping}

The \textbf{subtyping} relation $S\sq T$ is the order generated by
\begin{compactitem}
 \item $Prime\sq Pos\sq N\sq Z\sq Q\sq R\sq C$
 \item $T(k)\sq T(\_)$ for any type constructor $T$ (not necessarily unary) that allows a wildcard parameter
 \item All collecting and aggregating type constructors are covariant in all type arguments. For example, if $S\sq T$, then $List(S)\sq List(T)$.
 \item Horizontal subtyping: Record types become smaller, labeled disjoint union types bigger when adding fields.
 \item $FiniteMap$ is covariant in both type arguments.\footnote{Note that it is normal for \emph{partial} functions to be covariant in the domain.}
 \item $Ring\sq Field$
 \item For structures $s,S$ of type $T$, we have $s\sq S$ iff $s\leq_T S$. 
\end{compactitem}

Here we have used the submodel order $s\leq_T S$ which holds if $s$ is submodel of $S$ with respect to theory $T$.
$T$ can be the type of models of any theory, but for our purposes, it is sufficient to consider only the case $T\in\{Ring,Field\}$.
We use only the following sub-models
\begin{compactitem}
 \item $Z\leq_{Ring} Q\leq_{Field} R\sq\leq_{Field} C$
 \item $Polynomial(r,x)\leq_{Ring} Polynomial(s,y)$ if $r\leq_{Ring} s$ and every variable in $x$ also occurs in $y$.
 \item If $T\sq T'$, then $s\leq_T S$ implies $s\leq{T'}S$.
\end{compactitem}


%%% Local Variables:
%%% mode: latex
%%% mode: visual-line
%%% fill-column: 5000
%%% TeX-master: "report"
%%% End:

%  LocalWords:  app:expr compactitem ednote adic ldots,a_n ldots,a_n ldots,T_n cdots ldots Vec FiniteHybridset monoid Subtyping textbf sq emph leq_T leq_ leq_ leq_ r,x s,y leq
