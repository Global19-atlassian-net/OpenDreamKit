In this section, we describe the parts of the MitM ontology, which is a formal development in the MMT system.
The formalizations can be found at \url{https://gl.mathhub.info/MitM/}.
That location also contains various other archives in the \href{https://gl.mathhub.info/MitM/}{\texttt{MitM} library}, which are experiments, where the MitM ontology has been picked up by other projects.

\ednote{announce that the MitM solution consists of two parts
  Foundation + Core that will now be described}

\subsection{Foundation}

\ednote{$\operatorname{Field}$ looks nicer than than $Field$}

The foundation provides the type system and logic for the MitM ontology, i.e., the basic representational infrastructure used in the MitM ontology.
It is developed in the archive  \href{https://gl.mathhub.info/MitM/Foundation}{\texttt{Foundation}} (4 files, 539k LoF (lines
of formalization), 103 commits).

While the logic is relatively straightforward, the standardization of
the type system was very difficult because mathematics requires a
rich, open-ended type system, yet concrete implementations must stay as simple as possible.
After surveying the OpenDreamKit systems, we developed the types described below.

\ednote{reading through the exhaustive list of types is not super
  informative; move the list to the appendix, and just give a few
  examples of types, that are either typical, or where a specific
  design decision / curation step had to be taken}

\subsubsection{Types}

Concretely, the type system defines the following \textbf{types}:
\begin{itemize}
\item Base types
\begin{compactitem}
 \item number types (all unbounded in size):
  \begin{compactitem}
   \item natural numbers: $N$ (including $0$), $Pos$ (positive, excluding $0$), $Prime$ (prime numbers, not excluding $0$ and $1$)
   \item integer numbers: $Z$
   \item integer numbers modulo $m$: $Z(m)$ (for $m\in Pos$)
   \item rational numbers: $Q$
   \item real numbers: $R$ \ednote{FR: it's unclear which irrational numbers we need to support and how to represent them}
   \item complex numbers: $C$
   \item $p$-adic numbers: $Qp(p)$ (for prime $p$)
  \end{compactitem}
 \item strings: $String$
 \item booleans: $Boolean$
\end{compactitem}
\item Function types
 \begin{itemize}
 \item the type $T_1\to T_2$ of total functions from $T_1$ to $T_2$,
 \item shallow polymorphic types $\{a_1,\ldots,a_n\}T(a_1,\ldots,a_n)$ for a type $T$ with $n$ free type variables, with the restriction that polymorphic types may not occur as subexpressions of any of the other type constructors,
 \end{itemize}
\item Aggregating type constructors for types $T_1,\ldots,T_n$
\begin{compactitem}
 \item product types: $T_1*\cdots * T_n$
 \item record types: $\record{a_1: T_1, \ldots, a_n:T_n}$ for identifiers $a_i$
 \item disjoint union types: $T_1+\ldots + T_n$ \ednote{FR: not sure if we need these as they rarely come up yet as they are dual to product types}
 \item labeled disjoint union types: $\union{a_1:T_1,\ldots,a_n: T_n}$ for identifiers $a_i$ \ednote{FR: not sure if we need these as they rarely come up yet; they are dual to record types}
\end{compactitem}
In record and labeled disjoint union types, the order of fields is not relevant.
\item Collecting type constructors for any type $T$
\begin{compactitem}
 \item option types (list of length up to $1$): $Opt(T)$
 \item vectors (fixed-length lists): $Vec(T,n)$ for $n\in N$
 \item lists (arbitrary finite length): $List(T)$
 \item sets (finite subsets): $FiniteSet(T)$
 \item multisets (finite multiset subsets): $FiniteMultiset(T)$
 \item finite hybrid sets: $FiniteHybridset(T)$ are like multisets but also allow negative
   multiplicities.
 \item matrices: $Mat(T,m,n)$ for $m,n\in N$
\end{compactitem}
\item Erasure of dependent parameters: for a type constructor $T(k)$ (not necessarily unary) that takes a parameter $k$ of number type, we write $T(\_)$ for the type obtained by taking the unions over all possible parameters. In particular, we have
\begin{compactitem}
 \item $Mat(T,m,\_)$, $Mat(T,\_,n)$ and $Mat(T,\_,\_)$ for matrices with arbitrary dimensions
 \item $List(T)=Vec(T,\_)$
\end{compactitem}
\item Mathematical structures
\begin{compactitem}
 \item finite maps (partial functions with finite support): $FiniteMap(T_1,T_2)$ for types $T_i$
 \item polynomials: $Polynomial(r,[x_1,\ldots x_n])$ for ring $r\in Ring$ and identifiers $x_i$
 \item rings: $Ring$ (multiplication is a commutative monoid)
 \item fields: $Field$
 \item elements of structures: every structure $S$ (e.g., $S\in Ring$ or $S\in Field$) is a type itself; the elements of $S$ are represented as elements of the underlying type of $S$, which must be defined separately for every structure $S$.
\end{compactitem}
More generally than fixing $Ring$ and $Field$, we actually allow $Mod(T)$ for any theory $T$.
But the types listed above are sufficient for our purposes here.
\end{itemize}

The \textbf{subtyping} relation $S\sq T$ is the order generated by
\begin{compactitem}
 \item $Prime\sq Pos\sq N\sq Z\sq Q\sq R\sq C$
 \item $T(k)\sq T(\_)$ for any type constructor $T$ (not necessarily unary) that allows a wildcard parameter
 \item All collecting and aggregating type constructors are covariant in all type arguments. For example, if $S\sq T$, then $List(S)\sq List(T)$.
 \item Horizontal subtyping: Record types become smaller, labeled disjoint union types bigger when adding fields.
 \item $FiniteMap$ is covariant in both type arguments.\footnote{Note that it is normal for \emph{partial} functions to be covariant in the domain.}
 \item $Ring\sq Field$
 \item For structures $s,S$ of type $T$, we have $s\sq S$ iff $s\leq_T S$. 
\end{compactitem}

Here we have used the submodel order $s\leq_T S$ which holds if $s$ is submodel of $S$ with respect to theory $T$.
$T$ can be the type of models of any theory, but for our purposes, it is sufficient to consider only the case $T\in\{Ring,Field\}$.
We use only the following sub-models
\begin{compactitem}
 \item $Z\leq_{Ring} Q\leq_{Field} R\sq\leq_{Field} C$
 \item $Polynomial(r,x)\leq_{Ring} Polynomial(s,y)$ if $r\leq_{Ring} s$ and every variable in $x$ also occurs in $y$.
 \item If $T\sq T'$, then $s\leq_T S$ implies $s\leq{T'}S$.
\end{compactitem}

\subsubsection{Expressions}

The logic allows the following \textbf{formulas}, i.e., expression of type $Boolean$:
\begin{itemize}
\item the propositional connectives: conjunction, disjunction, implication, negation, and equivalence of formulas as well as truth and falsity,
\item typed equality: $t\doteq_T t'$ for any two terms $t,t'$ of type $T$,
\item typed quantifiers: $\forall x:T.F(x)$ and $\exists x:T.F(x)$ for a type $T$ and a formula $F$,
\end{itemize}
Additionally, we allow shallow quantification over types: ${a}F(a)$ for a formula $F$ and a type variable $a$ is a formula but it may not --- to avoid inconsistency issues --- occur as a subformula of any of the above formula constructors.

We do not give the remaining straightforward \textbf{term} constructors in detail and only remark on a few important aspects.
Most critically, we allow types to have multiple representations that are semantically equivalent but practically different in meaningful ways (e.g., because converting between representations is expensive or imprecise).

\paragraph{Integers Modulo}
The elements of $Z(m)$ are represented by $0,\ldots,m-1$.

\paragraph{Real Numbers}
A real number can be one of the following:
\begin{compactitem}
 \item a rational number
 \item an IEEE double precision float
 \item a root $\sqrt[n]{x}$ for $n\in N$ and $x\in Z$
 \item the strings "pi" and "e"
\end{compactitem}

\paragraph{Complex Numbers}
A complex number can be one of the following:
\begin{compactitem}
 \item Cartesian form $x+yi$
 \item polar form $r e^{i\phi}$
 \item root of unity $\zeta_n$
\end{compactitem}

\paragraph{p-Adic Numbers}
A $p$-adic number $x$ consists of unit $u\in N$ ($u,p$ co-prime), valuation $v\in Z$, and precision $r\in N$ (for $u<p^r$).

\paragraph{Polynomials}
For $r\in Ring$ and distinct strings $x_i$, we consider polynomials
\[p\in Polynomial(r,[x_1,\ldots,x_n])\]
to be of the form $p=\Sigma_{\vec{i}\in N^n} a_{\vec{i}} \vec{x}^{\vec{i}}$ where and $(x_1,\ldots,x^n)^{(i_1,\ldots,i_n)}$ abbreviates $x_1^{i_1}\cdot \ldots\cdot x_n^{i_n}$.

\paragraph{Rings}
A ring can be one of the following:
\begin{compactitem}
 \item a field
 \item $Polynomial(r,[x_1,\ldots,x_n])$ for $r\in Ring$
\end{compactitem}

\paragraph{Fields}
A field can be one of the following:
\begin{compactitem}
 \item base fields $Q$, $R$, and $C$
 \item finite fields $Z(p)$ for $p\in Prime$ (same type as integers modulo $p$)
 \item polynomial field extensions $FieldExtension(F,p,a)$ of $F\in Field$ for a polynomial $p\in Polynomial(F,[x])$ (for any variable name $x$)
 \item named fields identified by a string
\end{compactitem}

We define some abbreviations for common fields:
\begin{compactitem}
 \item $Q(p,a)=FieldExtension(Q,p,a)$
 \item $Qsqrt(n,a)=Q(x^2-n,a)$
 \item $Qzeta(n,a)=Q(y_n,a)$ where $y_n$ is the $n$-th cyclotomic polynomial
\end{compactitem}

We do not define $GF(q)$ for $q=p^n$ as an abbreviation for $FieldExtension(Z(p),g)$ for some irreducible polynomial $g\in Polynomial(Z(p))$ of degree $n$ because there is no way to choose $g$ canonically and it is necessary to know $g$ to represent the elements of $GF(q)$.

\paragraph{Structure Elements}
Every structure has an underlying type, which is used to represent its elements.

The underlying types of fields are defined as follows:
For $Q$, $R$, $C$, and $Z(p)$, the underlying type is the field itself.
The underlying type of $FieldExtension(F,p,a)$ is $Polynomial(F,[a])$ ($a=x$ is allowed).

% % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{MitM Core}

The \textbf{MitM core} in the
  \href{https://gl.mathhub.info/MitM/smglom}{\texttt{smglom}}\footnote{The name
    \texttt{smglom} was initially chosen for the ``Semantic Multilingual Glossary of
    Mathematics'' (SMGloM; see \ref{sec:smglom} below) with which it is
    cross-referenced. We will rethink naming once the MitM Ontology stabilizes.}  archive
  (43 files, 2600 LoF, 370 commits). It carries the bulk of the knowledge representation in
  the MitM Ontology. The main thrust of curation has been to get the VRE use cases
  reported on in~\cite{ODK-D6.5}, but we also have elementary formalizations of algebra,
  arithmetics, calculus, category theory, set collections, elliptic curves (for LMFDB),
  functional analysis, geometry, graph theory, measure theory, set theory, and topology.


In the sequel, we describe two exemplary parts of the MitM core ontology.

\subsubsection{Computational Group Theory}

\ednote{specify file name and size of the ontology}
Our formalization of CGT follows the template of its implementation in \GAP, and requires several levels of abstraction -- currently \emph{abstract}, \emph{representation}, \emph{implementation}, and \emph{concrete}. From our experience, we expect this pattern to be applicable across computational algebra, possibly with additional levels of abstraction. 
The left box in Figure \ref{fig:cgtontology} gives an overview.

The abstract level contains the axioms and basic definitions of the theory of \emph{Groups}: generating sets, homomorphisms, group actions, stabilisers, and orbits.
The most basic part is given in Figure~\ref{fig:mitm1}. 
\begin{figure}[ht]\centering
  \fbox{\includegraphics[width=8cm]{../MACIS17-interop/mitm1}}
  \caption{A Formalization of a Group}\label{fig:mitm1}
\end{figure}

At the representation level groups are described as concrete objects
suitable for computations: groups of permutations, groups of matrices,
finitely presented groups, groups obtained by algebraic constructions or using
polycyclic presentations.

At the implementation level, we encode implementation details: for
example, permutation groups are considered as finite subgroups of the group $S_{\mathbb{N}+}$, and defined \ednote{constructed?} by
providing a set of generating permutations.

At the concrete level, the computation happens: while the higher levels
are suitable for mathematical deduction and inference, this level is where OpenDreamKit systems like \GAP perform their main work.

\subsubsection{Modeling and Simulation}

The \href{https://gl.mathhub.info/MitM/smglom}{\texttt{models}}
archive (11 files, 650 LoF, 113 commits) is an experimental extension
of the MitM ontology, where we test the expressive power of MitM
framework (and the OpenDreamKit technologies) by applying it to a
field well outside of mathematics, namely for modeling and simulation
in opto-electronics.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "report"
%%% End:

%  LocalWords:  formalizations texttt formalization standardization subsubsection textbf
%  LocalWords:  compactitem ednote adic ldots,a_n ldots,a_n ldots,T_n ldots Vec monoid sq
%  LocalWords:  FiniteHybridset subtyping emph leq_T leq_ leq_ leq_ r,x s,y leq doteq_T
%  LocalWords:  t,t forall subformula u,p ldots,x cdot cdot Qsqrt Qzeta th smglom fbox
%  LocalWords:  stabilizes fig:cgtontology fig:mitm1 centering includegraphics mathbb
