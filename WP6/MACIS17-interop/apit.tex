In our case study, we want to show integration of the \GAP, \Singular, and \Sage systems
in the MitM paradigm, so we need to generate API CDs for all of them and equip them with
OpenMath phrasebooks. The three systems are sufficiently different that we can consider
the development presented in this section a meaningful case study in the methodology and
investment of exposing the APIs of real-world systems in the form of \OMMT content
dictionaries.

\begin{newpart}{MK: I have completely reworked this and tried to tell a consistent story
    here. @MP: please re-read and correct.}
\subsection{\GAP API Content Dictionaries}

In \cite{DehKohKon:iop16} we describe our approach to export knowledge in the form of type
information from the \GAP system and produce a full \GAP API CD. This has been
considerably improved in the meantime. 

One of the measures is that since then the \emph{MitM foundation\ednote{MK@DM: introduce
    that in CGT above} as improved so that the primitives of \GAP's type system can be
  expressed in \OMMT natively}\footnote{It is subject to future investigation whether
  \MMT can serve as an external type-checker for \GAP.}: \GAP's type system is based on
sub-typing: \emph{Filters} express finer and finer subtypes of the universal
\emph{IsObject}. An object in \GAP can learn about its properties, meaning its type is
refined at runtime: A group can learn that it is Abelian or nilpotent and hence its type
changes.

The second measure was to \emph{upgrade the pre-existing \GAP phrasebook from the standard
  OpenMath CDs to the \GAP system dialect}. For this we needed to devise and implement a
special treatment of the \GAP constructors used to represent native \GAP objects. As \GAP
only had a weak notion of object construction, we achieve this by identifying functions
that create objects in the \GAP code base and then instrumenting them to store the
relevant arguments they were called with.  The instrumentation itself is minimal -- 57
lines of \GAP code, plus 100 lines for serializing and parsing \GAP objects as OpenMath
objects: this is all that was needed for the phrasebook.  The main -- and indeed
considerable -- challenge was to identify functions that construct objects, and which
arguments of those functions are then stored in the object.  In \GAP, objects are created
by calling the function \lstinline|Objectify| with a type and some data, hence we analyzed
all call-sites to this function and some light inference of the enclosing function. In the
\GAP library there are 665 calls to Objectify, and in the standard package distribution
there are an additional 1664.

Developing the instrumentation lead to many improvements of type-handling infrastructure
in \GAP itself, and the instrumentation will be integrated into a future version of \GAP,
making \GAP fully MitM capable\footnote{We expect to reap a considerable fringe benefit of
  the type information in the constructor annotations: static type analysis can be used to
  optimize the dynamic method dispatch and thus hopefully lead to efficiency gains in the
  system.}\ednote{@MP think about ``why not just'' using the arguments to Objectify, this
  would of course also be stored, but looks even more minimal} With the constructor
annotation in place it is possible to have \GAP represent any object in a running session
as either a primitive type (integers, permutations, transformations, lists, floats,
strings), for which standard OpenMath CDs are used, or a constructor applied to a list of
arguments. This lends itself perfectly to a representation in the \GAP API CD.
 
Finally, for the \GAP operations, we needed to develop a new regime for disambiguating
names between generic methods and their type instances\ednote{MK@MP: I think you can say a
  little bit more here. Else delete this sentence.}

\ednote{MP: Put an example of OM\_Print here, maybe for a group, or for Cosets
  (as they are something that the standard OpenMath CDs in \GAP cannot do)}

\subsection{\Sage API Content Dictionaries}
\ednote{MK@NT: please write something here, this can be a bit more elaborate
than the \GAP part above, since \GAP has already been described in the CICM16
paper. What is the state of the OM Phrasebook for \Sage?}

As in \GAP, a large part of the mathematical knowledge embedded in the
\Sage library is encoded using its type system. This library is
written in the \Python programming language which comes with a
traditional object oriented dynamic type system.
For example The MiTM ontology of Figure~\ref{fig:cgtontology}
translates into a hierarchy of four abstract classes (\texttt{Group},
\texttt{PermutationGroup}, \texttt{MatrixGroup},
\texttt{FinitelyPresentedGroup}) and concrete classes
(\texttt{SymmetricGroup}, \texttt{MathieuGroup},
\texttt{LinearMatrixGroup}, ...).

Altogether, the hierarchy of classes of \Sage contains thousands of
abstract and concrete classes, with heavy use of multiple inheritance.
To tame code bloat and make such a deep and large hierarchy
maintainable, \Python's type system is enriched with a category system
that collects closely related abstract classes (e.g. \texttt{Group},
\texttt{GroupElement}, \texttt{GroupMorphism}, \texttt{GroupHomset}),
together with explicitly represented mathematical knowledge, in a
so-called \emph{category} (e.g that of \texttt{Groups}).
See~\ref{Sage,Sage.Categories} for details.

In \cite{DehKohKon:iop16} we describe the use of annotations in the code to enrich the
mathematical knowledge in \Sage's categories with alignments with other systems, notably
\MMT. This knowledge is then exported to generate interfaces theories. We also describe how
this can be used to automatically generate \emph{handle interfaces} with other systems
like e.g. \GAP.
\begin{todolist}{NT@NT}
\item explain what a handle interface is; advantages and limitations.\ednote{MK@NT: there
    is something about handles in the CICM16 paper, do you have more now? }
\item next step: also export constructors to enable non-handle interfaces where objects
  are actually exchanged. Besides, by nature certain areas of \Sage (e.g. graph theory,
  elliptic curves, ...) have shallow hierarchy of classes; there categories become
  irrelevant and are not used. \ednote{statistics would be useful here}
\item using introspection to export the information; instrument TestSuite to export all
  objects; parents and unique representation objects have a constructor method. pickling
  by construction, ...
\end{todolist}

\subsection{Standard OpenMath CDs as a \Singular API}

As we only need a very small part of \Singular for our case study, we were able to get by
with the OpenMath CDs for polynomials~\cite{OMCD:poly:on}. These are part of the standard
OpenMath CDs, a group of content dictionaries that describe (some) mathematical objects at
a high level of abstraction to be universally applicable. Building on the OpenMath
toolkits for OpenMath phrasebooks~\cite{py-openmath:on} and SCSCP
communication~\cite{py-scscp:on} in \Python -- which were developed for \Sage in the
OpenDreamKit project, we wrapped \Singular in a thin layer of python code that provides
\SCSCP communication. This work was undertaken by the sixth author as part of a summer
internship in about a week without prior expert knowledge of the system.
\end{newpart}
\ednote{MK@MK: say somewhere that expressing the CAS type systems natively in the MitM
  foundation puts all of the API CDs (and the MitM ontology) into a joint meaning space
  even though the system foundations are different. The interesting bit is that
  interoperability is at the ``Math level'' rather than at the ``system level''.}

\subsection{Alignments}

The initial alignments were produced by manually, but from some of the initial alignments
and the \GAP API CDs we will be able to infer more alignments automatically.  For example,
the filter \texttt{GAP:IsGroup}\ednote{MK: introduce the namespaces above} is aligned with
\texttt{mitm:Group}, and the filter \texttt{GAP:IsPermGroup} is aligned with
\texttt{mitm:Subgroup SymmetricGroup [1..n]}.  \ednote{MP: Need to be more concrete here,
  in particular we should maybe describe how \GAP's notion of an action homomorphism
  translates through this?  Also is this even correct?}

We formalised the theory of symmetric groups of a set; in \GAP permutation groups
are represented as subgroups (with finite support) of the symmetric group of
$\mathbb{N}+$, and often one concretely has an isomorphism between the group one
is interested in and a subgroup of $S_{\mathbb{N}+}$, for example
via a group action.

\texttt{SylowSubgroup}s are more difficult: They are special groups in their
own right, namely groups whose size is a prime-power, but we also want them
to be identified with a certain subgroup of the group we are working
with.\ednote{MP: While I believe this to be an excellent additional example
  for \OMMT formalisation, this could be going too far for this paper}

\begin{newpart}{MK@DM+NT: please check this }
  Another source of alignments are the existing ad-hoc \Sage-to-$X$ translations. These
  are (mainly) given as \Sage code annotations that relate \Sage operations and
  constructors with those of system $X$. We can harvest\ednote{MK@NT: I think you already
    do that, if so, please document above, if not, please do!} those as alignments between
  the \Sage API CDs and $X$ API CDs. These can be combined with the \Sage-to-MitM
  alignments into $X$-to-MitM alignments. While $X$-to-$Y$ alignments are the application,
  $X$/$Y$-to-MitM alignments scale better, since they can be arbitrarily combined and make
  the induced knowledge management workflows star-shaped.
\end{newpart}
\ednote{MK@MK: still two write: the alignment-based priorization and suggestion mechanism. }
