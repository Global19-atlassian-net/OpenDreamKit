\section{API Content Dictionaries for GAP and SageMath}\label{sec:apit}
\begin{todolist}{MK: some of this has already been discussed in the CICM16 paper, }
\item MK@NT+DM: describe the SageMath API theory and how it is generated; this is
  new. 
\item MK@MK+NT+MP: compare and discuss the different generation approaches\ednote{MK: do
    we have an APIT for Singular yet? MP: We do not, we should whip one up, at
    least for the most basic bits of Singular}
\item MK@MK: conclude the section by a discussion about OpenMath and Dialects.
\end{todolist}


\subsection{GAP API Content Dictionaries}
\ednote{MK@MP+DM: describe the GAP API theory and how they are generated; give the numbers, but only give the diffs to the CICM16 paper.}

In \cite{DehKohKon:iop16} we describe our approach to export knowledge in the
form of type information from the GAP system. We export all created types
together with relationships between them to a json file, which is then imported
into MMT.

We also defined the primitives of GAP's type system in OMDoc/MMT, and it is
subject to future investigation whether MMT can serve as an external typechecker
for GAP.

GAP's type system is based on sub-typing: \emph{Filters} express finer and finer
subtypes of the universal \emph{IsObject}. An object in GAP can learn about its
properties, meaning its type is refined: A group can learn that it is abelian or
nilpotent and hence its type changes.

For a successful implementation of an MitM system it is necessary to know how
a given object in an ongoing session has been created. In GAP we achieve this by
identifying functions that create objects, and then instrumenting them to store
their arguments. The instrumentation itself is minimal (57 lines of GAP code,
plus 100 lines for printing objects as OpenMath). The main challenge was
to identify functions that construct objects. In GAP objects come to be by
calling the function \texttt{Objectify} with a type and some data, and hence all
that was needed was an analysis of call-sites to this function and some light
inference of the enclosing function.
Developing the instrumentation lead to many improvements of type-handling
infrastructure in GAP itself, and the instrumentation will be integrated into a
future version of GAP, making GAP fully MitM capable.

In the GAP library there are 665 calls to Objectify, and in the standard package
distribution there are 1664.

With the constructor annotation in place it is possible to have GAP represent
any object in the workspace as either a primitive type, for which standard
OpenMath CDs are used, or a constructor applied to a list of arguments. This
lends itself perfectly to a representation in the GAP API CD.

\ednote{MP: Put an example of OM_Print here, maybe for a group, or for Cosets
  (as they are something that the standard OpenMath CDs in GAP cannot do)}

\ednote{MK@MP: we also need to talk about the OM Phrasebook (see
  Section~\ref{sec:mitm}), and how that works. Actually I think that this is
  really the new part we want to discuss here.}

\subsection{SageMath API Content Dictionaries}
\ednote{MK@NT: please write something here, this can be a bit more elaborate
than the GAP part above, since GAP has already been described in the CICM16
paper. What is the state of the OM Phrasebook for SageMath?}

\subsection{Creation Of Singular API CDs}
\ednote{MK: it would be great, if we could do this and als have an estimation of
the time used for this.}

\subsection{Comparison of Approaches}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "paper"
%%% End:

%  LocalWords:  sec:apit DehKohKon:iop16 json emph emph sec:mitm
